This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  do/
    mockup_queue.js
    session.js
  routes/
    admin.js
    imageUtils.js
    protected.js
    public.js
    webhooks.js
    websockets.js
  auth.js
  index.js
  printful.js
  scheduled.js
  seed.js
tests/
  designs.test.js
  products.test.js
.editorconfig
.gitignore
.prettierrc
local_schema.sql
package.json
schema.sql
wrangler.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/do/mockup_queue.js">
// api/src/do/mockup_queue.js

// Placeholder for Mockup Generation Queue Durable Object
// Will accept jobs, store them, and potentially process them or call external APIs (like Printful mockup API)

export class MockupQueueDurableObject {
    constructor(state, env) {
        this.state = state;
        this.env = env;
        this.printfulApiKey = env.PRINTFUL_API_KEY;
        this.db = env.DB;
    }

    async fetch(request) {
        const url = new URL(request.url);

        if (url.pathname === '/queue' && request.method === 'POST') {
            return this.handleQueueRequest(request);
        }

        return new Response('Not found', { status: 404 });
    }

    async handleQueueRequest(request) {
        if (!this.printfulApiKey) {
            console.error('[DO MockupQueue] PRINTFUL_API_KEY not set in environment.');
            return new Response('Internal Server Error: Printful API Key missing', { status: 500 });
        }
        if (!this.db) {
            console.error('[DO MockupQueue] DB binding not available.');
            return new Response('Internal Server Error: Database binding missing', { status: 500 });
        }

        let taskData;
        try {
            taskData = await request.json();
            if (!taskData.designId || !taskData.imageUrl || !taskData.variantId) {
                throw new Error('Missing required fields: designId, imageUrl, variantId');
            }
        } catch (e) {
            console.error('[DO MockupQueue] Failed to parse task data:', e);
            return new Response(`Bad Request: ${e.message}`, { status: 400 });
        }

        const { designId, imageUrl, variantId } = taskData;
        console.log(`[DO MockupQueue] Received task for design ${designId}`);

        try {
            // 1. Get Printful Variant ID from DB
            const variantInfo = await this.db.prepare(
                `SELECT printful_variant_id, print_area_width, print_area_height, print_area_top, print_area_left
                 FROM product_variants WHERE id = ?`
            ).bind(variantId).first();

            if (!variantInfo || !variantInfo.printful_variant_id) {
                throw new Error(`Could not find Printful variant ID or print area for DB variant ${variantId}`);
            }
            
            const printfulVariantId = variantInfo.printful_variant_id;
            console.log(`[DO MockupQueue] Found Printful variant ID: ${printfulVariantId} for DB variant ${variantId}`);

            // 2. Construct Printful Mockup Task Payload
            //    Positioning Logic: Center the image within the print area.
            //    Printful's API positions based on the *print area* coordinates, not the template.
            //    Assuming the image is intended to fill the print area width/height for now.
            //    More sophisticated logic (scaling, aspect ratio handling) might be needed later.
            const printfulPayload = {
                variant_ids: [printfulVariantId],
                format: 'png', // Request PNG mockups
                files: [
                    {
                        placement: 'front', // Assuming 'front' placement for now
                        image_url: imageUrl,
                        position: { // Center within the print area
                            area_width: variantInfo.print_area_width,
                            area_height: variantInfo.print_area_height,
                            width: variantInfo.print_area_width, // Use full print area width
                            height: variantInfo.print_area_height, // Use full print area height
                            top: 0, // Position relative to print area top-left
                            left: 0 // Position relative to print area top-left
                        }
                    }
                ],
                // Use designId as external_id for webhook correlation
                external_id: designId.toString() 
            };

            // console.log(`[DO MockupQueue] Calling Printful Mockup API for design ${designId}... Payload:`, JSON.stringify(printfulPayload, null, 2));
            console.log(`[DO MockupQueue] Calling Printful Mockup API for design ${designId}...`);

            // 3. Call Printful API
            const printfulApiUrl = 'https://api.printful.com/v2/mockup-tasks';
            const printfulResponse = await fetch(printfulApiUrl, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${this.printfulApiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(printfulPayload)
            });

            const printfulResult = await printfulResponse.json();

            if (!printfulResponse.ok) {
                console.error(`[DO MockupQueue] Printful API error for design ${designId}:`, printfulResponse.status, printfulResult);
                // Update design status to indicate error?
                await this.updateDesignStatus(designId, 'mockup_error');
                throw new Error(`Printful API request failed with status ${printfulResponse.status}`);
            }

            // console.log(`[DO MockupQueue] Printful mockup task created successfully for design ${designId}:`, printfulResult);
            console.log(`[DO MockupQueue] Printful mockup task created successfully for design ${designId}. Task key: ${printfulResult?.task_key}`);

            // Update design status to pending
            await this.updateDesignStatus(designId, 'mockup_pending');

            return new Response(JSON.stringify({ success: true, message: 'Mockup task queued with Printful' }), { status: 200 });

        } catch (error) {
            console.error(`[DO MockupQueue] Error processing mockup task for design ${designId}:`, error);
            // Attempt to update design status to error
            try {
                 await this.updateDesignStatus(designId, 'mockup_error');
            } catch (dbError) {
                console.error(`[DO MockupQueue] Failed to update design ${designId} status to error after task failure:`, dbError);
            }
            return new Response(`Internal Server Error: ${error.message}`, { status: 500 });
        }
    }

    // Helper to update design status in D1
    async updateDesignStatus(designId, status) {
        try {
            await this.db.prepare(
                `UPDATE designs SET status = ?, updated_at = datetime('now') WHERE id = ?`
            ).bind(status, designId).run();
            console.log(`[DO MockupQueue] Updated status for design ${designId} to ${status}`);
        } catch (dbError) {
            console.error(`[DO MockupQueue] Failed to update DB status for design ${designId} to ${status}:`, dbError);
            // Re-throw? Or just log?
            throw dbError; // Re-throw so the caller knows the update failed
        }
    }
}
</file>

<file path="src/do/session.js">
// api/src/do/session.js

// Placeholder for Session Management Durable Object
// Will handle WebSocket connections for real-time updates (e.g., mockup status)

export class SessionDurableObject {
    constructor(state, env) {
        this.state = state;
        this.env = env;
        this.sessions = []; // Store WebSocket sessions
        // Potentially load state from storage
        // this.state.blockConcurrencyWhile(async () => {
        //     this.value = await this.state.storage.get("value") || 0;
        // });
    }

    // Handle HTTP requests (e.g., WebSocket upgrade)
    async fetch(request) {
        const url = new URL(request.url);

        // Handle WebSocket upgrade requests from the main worker router
        if (url.pathname.endsWith('/api/ws')) { // Match based on how router forwards
            if (request.headers.get("Upgrade") != "websocket") {
                return new Response("Expected Upgrade: websocket", { status: 400 });
            }
            const [client, server] = Object.values(new WebSocketPair());
            await this.handleSession(server);
            return new Response(null, { status: 101, webSocket: client });

        // Handle internal notification requests from other parts of the worker (e.g., webhook handler)
        } else if (url.pathname === '/notify' && request.method === 'POST') { 
            try {
                const notificationData = await request.json();
                console.log('[SessionDO] Received notification:', notificationData);
                this.broadcast(notificationData); // Broadcast the received data
                return new Response(JSON.stringify({ success: true }), { status: 200 });
            } catch (e) {
                console.error('[SessionDO] Failed to process notification:', e);
                return new Response('Invalid notification data', { status: 400 });
            }
        } else {
             // Not a WebSocket upgrade or internal notification
             return new Response('Not found', { status: 404 });
        }
    }

     // Handle WebSocket session
    async handleSession(webSocket) {
        webSocket.accept();
        this.sessions.push(webSocket);

        webSocket.addEventListener("message", async event => {
            console.log("DO received message:", event.data);
            // Echo message back or handle client messages
            // webSocket.send(JSON.stringify({ message: "DO received: " + event.data }));
        });

        webSocket.addEventListener("close", async event => {
            console.log("DO session closed");
            this.sessions = this.sessions.filter(s => s !== webSocket);
        });

         webSocket.addEventListener("error", async event => {
            console.error("DO session error:", event);
            this.sessions = this.sessions.filter(s => s !== webSocket);
        });
    }

    // Broadcast a message to all connected WebSocket clients
    broadcast(message) {
        const messageString = typeof message === 'string' ? message : JSON.stringify(message);
        console.log(`Broadcasting message to ${this.sessions.length} sessions: ${messageString}`);
        this.sessions = this.sessions.filter(session => {
            try {
                session.send(messageString);
                return true;
            } catch (err) {
                console.error("Failed to send message to session, removing:", err);
                return false; // Remove broken session
            }
        });
    }
    
     // Example of internal method callable via RPC or other means
    async notify(data) {
        console.log("DO notify called with:", data);
        this.broadcast({ type: 'notification', payload: data });
        // Persist state if needed
        // await this.state.storage.put("lastNotification", data);
    }

}
</file>

<file path="src/routes/admin.js">
import { Hono } from 'hono';
import { seedProductData } from '../seed'; // Assuming seed logic is in seed.js

const adminRoutes = new Hono();

// --- Admin Routes ---

// POST /api/admin/seed-product
adminRoutes.post('/seed-product', async (c) => {
    const env = c.env; // Get env from context first
    // Correctly use context (c) to access request headers and env
    if (c.req.headers.get('X-Admin-Secret') !== env.ADMIN_AUTH_KEY) { 
        return c.json({error: 'Unauthorized'}, 401); // Use c.json for consistency
    }

    const productId = '586'; // Hardcoding the target product ID for now
    const targetColors = [
        'Berry', 'Black', 'Blue Jean', 'Brick',
        'Grey', 'Moss', 'True Navy', 'White',
    ];

    console.log(`Received request to seed product ID: ${productId}`);

    try {
        const result = await seedProductData(env, productId, targetColors);
        console.log('Seed Result:', result);
        if (result.success) {
            return c.json(result);
        } else {
            return c.json(result, 500);
        }
    } catch (err) {
        console.error("Unhandled error in seed endpoint:", err);
        return c.json({ success: false, message: 'Internal server error during seeding.' }, 500);
    }
});

// POST /api/admin/import-product/:productId
adminRoutes.post('/import-product/:productId', async (c) => {
    const env = c.env;
    if (c.req.headers.get('X-Admin-Secret') !== env.ADMIN_AUTH_KEY) {
        return c.json({ error: 'Unauthorized' }, 401);
    }

    const { productId } = c.req.param();
    console.log(`Received request to import product ID: ${productId}`);

    try {
        // Assuming seedProductData can handle product-specific logic
        // and may not require targetColors for all product types.
        // Passing an empty array or null if colors are not applicable for the given product.
        const result = await seedProductData(env, productId, []); 
        console.log('Import Result:', result);
        if (result.success) {
            return c.json(result);
        } else {
            return c.json(result, result.status || 500); // Use status from result if available
        }
    } catch (err) {
        console.error(`Error importing product ID ${productId}:`, err);
        return c.json({ success: false, message: 'Internal server error during product import.' }, 500);
    }
});

export default adminRoutes;
</file>

<file path="src/routes/imageUtils.js">
import { Hono } from 'hono';

const imageUtils = new Hono();

// Route to remove background using Pixian AI
imageUtils.post('/remove-background', async (c) => {
  const { PIXIAN_API_ID, PIXIAN_API_SECRET } = c.env;

  if (!PIXIAN_API_ID || !PIXIAN_API_SECRET) {
    console.error('Pixian API credentials missing in environment variables.');
    return c.json({ error: 'Configuration error', message: 'Background removal service is not configured.' }, 500);
  }

  try {
    const formData = await c.req.formData();
    const imageFile = formData.get('image');

    if (!imageFile || !(imageFile instanceof File || imageFile instanceof Blob)) {
      return c.json({ error: 'Bad Request', message: 'No image file provided or invalid format.' }, 400);
    }

    // Prepare FormData to send to Pixian
    const pixianFormData = new FormData();
    pixianFormData.append('image', imageFile, imageFile.name || 'image_to_process.png'); // Use original name if available
    pixianFormData.append('output_format', 'png');
    pixianFormData.append('result.crop_to_foreground', 'true');

    // Encode credentials for Basic Auth
    const credentials = btoa(`${PIXIAN_API_ID}:${PIXIAN_API_SECRET}`);

    const pixianApiUrl = 'https://api.pixian.ai/api/v2/remove-background';

    console.log(`Calling Pixian API for background removal...`);

    const pixianResponse = await fetch(pixianApiUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Basic ${credentials}`,
        // 'Content-Type' is set automatically by fetch when using FormData body
      },
      body: pixianFormData,
    });

    if (!pixianResponse.ok) {
      let errorBody = 'Failed to parse Pixian error response.';
      try {
         errorBody = await pixianResponse.text();
      } catch (e) { /* Ignore parsing error */ }
      console.error(`Pixian API Error: ${pixianResponse.status} ${pixianResponse.statusText}`, errorBody);
      return c.json({ error: 'Background removal failed', message: `Upstream service returned status ${pixianResponse.status}. ${errorBody}` }, 502); // 502 Bad Gateway
    }

    console.log(`Pixian API call successful.`);

    // Get the resulting image as a Blob
    const resultBlob = await pixianResponse.blob();

    // Return the resulting image blob directly to the client
    // Set appropriate headers for the client
    c.header('Content-Type', resultBlob.type || 'image/png'); // Use type from Pixian if available, else default
    c.header('Content-Disposition', 'inline; filename="background_removed.png"'); // Suggest filename
    
    return c.body(resultBlob);

  } catch (error) {
    console.error('Error processing background removal request:', error);
    if (error instanceof Error) {
        return c.json({ error: 'Internal Server Error', message: error.message }, 500);
    } else {
        return c.json({ error: 'Internal Server Error', message: 'An unknown error occurred.' }, 500);
    }
    
  }
});

export default imageUtils;
</file>

<file path="src/routes/protected.js">
import { Hono } from 'hono';
import { authMiddleware } from '../auth'; // Import auth middleware

// Helper function to generate a unique filename (e.g., UUID)
// Using Web Crypto API available in Workers
function generateUUID() {
    return crypto.randomUUID();
}

// Helper to get file extension
function getExtension(filename) {
    return filename.substring(filename.lastIndexOf('.') + 1) || 'png'; // Default to png if no extension
}

const protectedRoutes = new Hono();

// Apply auth middleware to all routes in this file
protectedRoutes.use('*', authMiddleware);

// --- Protected Routes ---

// GET /api/designs - List user's designs
protectedRoutes.get('/designs', async (c) => {
  const userFid = c.get('userFid');
  if (!userFid) {
    // Should be caught by middleware, but belt-and-suspenders
    return c.json({ error: 'Unauthorized: Missing user FID in context' }, 401);
  }

  try {
    const { results } = await c.env.DB.prepare(
      `SELECT id, product_id, variant_id, image_url, mockup_url, status, is_public, created_at, updated_at
       FROM designs WHERE fid = ? ORDER BY created_at DESC`
    ).bind(userFid).all();
    return c.json({ designs: results || [] });
  } catch (e) {
    console.error("Error fetching user designs:", e);
    return c.json({ error: 'Failed to fetch designs' }, 500);
  }
});

// POST /api/designs - Create a new design (handles multipart/form-data)
protectedRoutes.post('/designs', async (c) => {
    const userFid = c.get('userFid');
    if (!userFid) {
        return c.json({ error: 'Unauthorized: Missing user FID in context' }, 401);
    }

    let formData;
    try {
        formData = await c.req.formData();
    } catch (e) {
        console.error("Error parsing form data:", e);
        return c.json({ success: false, message: 'Invalid form data' }, 400);
    }

    const product_id = formData.get('product_id');
    const variant_id = formData.get('variant_id');
    const imageFile = formData.get('image'); // Assuming the file input name is 'image'

    // Validation
    if (!product_id || !variant_id || !(imageFile instanceof File)) {
        return c.json({ success: false, message: 'Missing required fields: product_id, variant_id, and image file' }, 400);
    }

    if (!c.env.R2_BUCKET || !c.env.R2_PUBLIC_URL) {
        console.error('R2 environment variables not configured');
        return c.json({ success: false, message: 'Server configuration error for image storage.' }, 500);
    }

    const db = c.env.DB;
    const r2 = c.env.R2_BUCKET;
    const r2PublicUrl = c.env.R2_PUBLIC_URL;

    try {
        // Generate R2 key
        const fileExtension = getExtension(imageFile.name);
        const uniqueFilename = `${generateUUID()}.${fileExtension}`;
        const r2Key = `user-images/${userFid}/${product_id}/${uniqueFilename}`;

        // Upload to R2
        await r2.put(r2Key, await imageFile.arrayBuffer(), {
            httpMetadata: { contentType: imageFile.type || 'image/png' }
        });
        const imageUrl = `${r2PublicUrl.replace(/\/$/, '')}/${r2Key}`;
        console.log(`Design image uploaded: ${imageUrl}`);

        // Insert into Database
        const result = await db.prepare(
            `INSERT INTO designs (fid, product_id, variant_id, image_url, status)
             VALUES (?, ?, ?, ?, 'draft') RETURNING id`
        ).bind(userFid, product_id, variant_id, imageUrl).first();

        const newDesignId = result?.id;
        if (!newDesignId) {
            // Attempt to clean up R2 upload if DB insert fails?
            // await r2.delete(r2Key);
            throw new Error("Failed to insert design into database after image upload.");
        }
        console.log(`Design DB record created for FID ${userFid} with ID ${newDesignId}.`);

        // Enqueue mockup generation task
        try {
            // Use the correct binding name from wrangler.toml
            const doBinding = c.env.MOCKUP_QUEUE_DO; 
            if (!doBinding) {
                throw new Error("MOCKUP_QUEUE_DO binding is not configured in wrangler.toml or not available in env.");
            }
            const doId = doBinding.idFromName("singleton"); // Use a consistent name for the queue DO
            const stub = doBinding.get(doId);

            // Send the task to the DO
            await stub.fetch('http://do-mockup-queue/queue', { // Use a dummy internal URL
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    designId: newDesignId,
                    imageUrl: imageUrl,
                    variantId: parseInt(variant_id) // Pass variant_id too, needed for Printful
                })
            });
            console.log(`Mockup task enqueued for design ID: ${newDesignId}`);
        } catch (doError) {
            console.error(`Failed to enqueue mockup task for design ${newDesignId}:`, doError);
            // Decide how to handle this: maybe update design status to 'queue_failed'?
            // For now, we'll just log it and return success for the design creation itself.
            // Optionally, could return a 202 Accepted with a warning.
        }

        return c.json({ success: true, designId: newDesignId, imageUrl: imageUrl }, 201);

    } catch (e) {
        console.error("Error processing design creation:", e);
        if (e.message && e.message.includes('FOREIGN KEY constraint failed')) {
            return c.json({ success: false, message: 'Invalid product_id or variant_id.' }, 400);
        }
        return c.json({ success: false, message: 'Failed to create design' }, 500);
    }
});

// POST /api/designs/:design_id/publish - Publish a design (stub)
protectedRoutes.post('/designs/:design_id/publish', (c) => {
    const userFid = c.get('userFid');
    const designId = c.req.param('design_id');
    console.log(`Publishing design ${designId} for user FID: ${userFid}`);
    // TODO: Implement publish logic (update is_public, set royalty, calculate price)
    return c.json({ message: `Publish design ${designId} for ${userFid} not implemented yet` }, 501);
});

// GET /api/orders - List user's orders (stub)
protectedRoutes.get('/orders', (c) => {
    const userFid = c.get('userFid');
    console.log(`Fetching orders for user FID: ${userFid}`);
    // TODO: Implement order fetching logic
    return c.json({ message: `User ${userFid} orders list not implemented yet` }, 501);
});

// POST /api/orders - Create an order (stub)
protectedRoutes.post('/orders', (c) => {
    const userFid = c.get('userFid');
    console.log(`Creating order for user FID: ${userFid}`);
    // TODO: Implement order creation logic
    return c.json({ message: `Create order for ${userFid} not implemented yet` }, 501);
});

// GET /api/orders/:order_id/signature - Generate payment signature (stub)
protectedRoutes.get('/orders/:order_id/signature', (c) => {
    const userFid = c.get('userFid');
    const orderId = c.req.param('order_id');
    console.log(`Generating signature for order ${orderId} requested by FID: ${userFid}`);
    // TODO: Implement signature generation logic
    return c.json({ message: `Generate signature for order ${orderId} (user ${userFid}) not implemented yet` }, 501);
});

export default protectedRoutes;
</file>

<file path="src/routes/public.js">
import { Hono } from 'hono';
import { handleSignIn } from '../auth'; // Assuming auth handler is separate

const publicRoutes = new Hono();

// --- Public Routes ---

// POST /api/auth/signin
publicRoutes.post('/auth/signin', async (c) => {
    return handleSignIn(c.req.raw, c.env);
});

// GET /api/products
publicRoutes.get('/products', async (c) => {
    const env = c.env;
    try {
        // Fetch all active products
        const { results: products } = await env.DB.prepare(
            "SELECT id, name, slug, printful_product_id FROM products WHERE status = 'active'"
        ).all();

        if (!products || products.length === 0) {
            return c.json({ products: [] });
        }

        // Fetch variants for all active products
        const placeholders = products.map(() => '?').join(',');
        const productIds = products.map(p => p.id);
        const query = `
          SELECT
            pv.id, pv.product_id, pv.printful_variant_id,
            pv.color_name, pv.color_code, pv.size, pv.printful_price,
            pv.inventory_count, pv.status,
            pv.template_image_url, pv.template_texture_url, pv.template_width, pv.template_height,
            pv.print_area_width, pv.print_area_height, pv.print_area_top, pv.print_area_left
          FROM product_variants pv
          WHERE pv.product_id IN (${placeholders})
            AND pv.status != 'discontinued'
          ORDER BY pv.product_id, pv.size
        `;
        const { results: allVariants } = await env.DB.prepare(query).bind(...productIds).all();

        // Group variants by product ID
        const variantsByProductId = allVariants.reduce((acc, variant) => {
            if (!acc[variant.product_id]) {
                acc[variant.product_id] = [];
            }
            acc[variant.product_id].push(variant);
            return acc;
        }, {});

        // Structure the response
        const responseProducts = products.map(product => {
            const productVariants = variantsByProductId[product.id] || [];
            const options = {
                color_name: [...new Set(productVariants.map(v => v.color_name))].sort(),
                size: [...new Set(productVariants.map(v => v.size))].sort((a, b) => {
                    const sizeOrder = { 'S': 1, 'M': 2, 'L': 3, 'XL': 4 };
                    return (sizeOrder[a] || 99) - (sizeOrder[b] || 99);
                }),
            };
            const colors = options.color_name.map(colorName => {
                const variantsOfColor = productVariants.filter(v => v.color_name === colorName);
                const representativeVariant = variantsOfColor.find(v => v.size === 'M') || variantsOfColor[0];
                const basePrice = representativeVariant ? representativeVariant.printful_price : null;
                const colorCode = representativeVariant ? representativeVariant.color_code : null;

                return {
                    color_name: colorName,
                    color_code: colorCode,
                    base_price: basePrice,
                    variants: variantsOfColor.map(v => ({
                        id: v.id,
                        printful_variant_id: v.printful_variant_id,
                        size: v.size,
                        inventory_count: v.inventory_count,
                        status: v.status,
                        base_price: v.printful_price,
                        template_image_url: v.template_image_url,
                        template_texture_url: v.template_texture_url,
                        template_width: v.template_width,
                        template_height: v.template_height,
                        print_area_width: v.print_area_width,
                        print_area_height: v.print_area_height,
                        print_area_top: v.print_area_top,
                        print_area_left: v.print_area_left,
                    })),
                };
            });
            return {
                id: product.id,
                printful_product_id: product.printful_product_id,
                name: product.name,
                slug: product.slug,
                options: options,
                colors: colors,
            };
        });
        return c.json({ products: responseProducts });
    } catch (e) {
        console.error("Error fetching products:", e);
        return c.json({ error: 'Error fetching products' }, 500);
    }
});

// GET /api/products/:product_id/variants
publicRoutes.get('/products/:product_id/variants', async (c) => {
    const productId = c.req.param('product_id');
    console.log(`Fetching variants for product ${productId}`);
    if (!productId) {
        return c.json({ error: "Missing product_id parameter" }, 400);
    }
    try {
        const { results: variants } = await c.env.DB.prepare(
            `SELECT id, color_name, size, inventory_count
             FROM product_variants
             WHERE product_id = ?`
        ).bind(productId).all();

        if (!variants) {
            console.error(`Error fetching variants for product ${productId}: Query failed`);
            return c.json({ error: "Failed to fetch variants" }, 500);
        }

        if (variants.length === 0) {
            const { results: productCheck } = await c.env.DB.prepare(
                `SELECT 1 FROM products WHERE id = ? LIMIT 1`
            ).bind(productId).all();
            if (!productCheck || productCheck.length === 0) {
                return c.json({ error: `Product with ID ${productId} not found` }, 404);
            }
        }
        const formattedVariants = variants.map(v => ({
            id: v.id,
            color_name: v.color_name,
            size: v.size,
            inventory_count: v.inventory_count
        }));
        return c.json({ variants: formattedVariants });
    } catch (error) {
        console.error(`Error fetching variants for product ${productId}:`, error);
        return c.json({ error: "Failed to fetch variants" }, 500);
    }
});

// GET /api/designs/:design_id (Public view)
publicRoutes.get('/designs/:design_id', (c) => {
    const designId = c.req.param('design_id');
    // TODO: Fetch public design details from D1 (where is_public = true)
    console.log(`Fetching public design ${designId}`);
    return c.json({ message: `Public view for design ${designId} not implemented yet` }, 501);
});

// GET /api/feed (Public)
publicRoutes.get('/feed', (c) => {
    const page = c.req.query('page') || 1;
    const limit = c.req.query('limit') || 10;
    // TODO: Fetch paginated public designs from D1
    console.log(`Fetching public feed (page=${page}, limit=${limit})`);
    return c.json({ message: 'Public feed not implemented yet' }, 501);
});

// NEW: Generate Nonce Endpoint
publicRoutes.get('/auth/nonce', async (c) => {
    try {
        // Generate a secure random nonce (e.g., using Web Crypto API if available in CF Workers)
        // crypto.randomUUID() is generally available and suitable
        const nonce = crypto.randomUUID().replace(/-/g, ''); // Remove hyphens for simplicity
        console.log('Generated nonce:', nonce);
        return c.json({ nonce });
    } catch (error) {
        console.error("Error generating nonce:", error);
        // Fallback if crypto API isn't available (less secure)
        try {
            const fallbackNonce = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
            console.warn('Using fallback nonce generation');
            return c.json({ nonce: fallbackNonce });
        } catch (fallbackError) {
             console.error("Fallback nonce generation also failed:", fallbackError);
             return c.json({ error: 'Failed to generate nonce' }, 500);
        }
    }
});

export default publicRoutes;
</file>

<file path="src/routes/webhooks.js">
import { Hono } from 'hono';

const webhookRoutes = new Hono();

// --- Webhook Routes ---

// POST /api/webhooks/printful
webhookRoutes.post('/printful', async (c) => {
    const db = c.env.DB;
    if (!db) {
        console.error('[Webhook Printful] DB binding not available.');
        return c.json({ error: 'Internal Server Error: Database binding missing' }, 500);
    }

    let payload;
    try {
        payload = await c.req.json();
        // console.log('[Webhook Printful] Received payload:', JSON.stringify(payload, null, 2));
    } catch (e) {
        console.error('[Webhook Printful] Failed to parse request body:', e);
        return c.json({ error: 'Invalid request body' }, 400);
    }

    // TODO: Implement Printful webhook signature verification if available/required
    // const signature = c.req.header('X-Printful-Signature'); // Example header
    // if (!isValidSignature(payload, signature, c.env.PRINTFUL_WEBHOOK_SECRET)) {
    //     console.warn('[Webhook Printful] Invalid signature received');
    //     return c.json({ error: 'Invalid signature' }, 401);
    // }

    const eventType = payload.type;
    const task = payload.data?.task; // Data structure might vary based on event
    const mockup = payload.data?.mockup; // Data structure for finished mockup

    // Check if it's a finished mockup task
    if (eventType === 'mockup_task_finished' && mockup) {
        const externalId = mockup.external_id;
        const mockupUrl = mockup.mockup_url;

        if (!externalId || !mockupUrl) {
            console.error('[Webhook Printful] Missing external_id or mockup_url in finished event', payload);
            return c.json({ error: 'Missing required data in webhook payload' }, 400);
        }

        const designId = parseInt(externalId, 10);
        if (isNaN(designId)) {
            console.error('[Webhook Printful] Invalid external_id (designId):', externalId);
            return c.json({ error: 'Invalid external_id' }, 400);
        }

        console.log(`[Webhook Printful] Mockup finished for design ${designId}. URL: ${mockupUrl}`);

        try {
            // Update the design record in D1
            console.log(`[Webhook Printful] Attempting update for ID: ${designId} with status IN check.`);
            await db.prepare(
                `UPDATE designs
                 SET mockup_url = ?, status = 'mockup_ready', updated_at = datetime('now')
                 WHERE id = ? AND status IN (?, ?)`
            ).bind(mockupUrl, designId, 'mockup_pending', 'draft').run();

            // Assume success if no error is thrown, as result.changes might be unreliable in local D1 simulation.
            console.log(`[Webhook Printful] Successfully updated design ${designId} with mockup URL (or assumed success).`);

            // Notify Session Durable Object via WebSocket
            try {
                // Get the FID associated with this design
                const designInfo = await db.prepare(
                    `SELECT fid FROM designs WHERE id = ?`
                ).bind(designId).first();

                if (designInfo && designInfo.fid) {
                    const userFid = designInfo.fid;
                    const sessionDoBinding = c.env.SESSION_DO;
                    if (!sessionDoBinding) {
                         console.error('[Webhook Printful] SESSION_DO binding missing. Cannot notify client.');
                    } else {
                        const doId = sessionDoBinding.idFromName(userFid.toString());
                        const stub = sessionDoBinding.get(doId);
                        // Send notification asynchronously (fire-and-forget)
                        stub.fetch('http://do-session/notify', { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ type: 'mockup_ready', designId, mockupUrl })
                        }); 
                        console.log(`[Webhook Printful] Sent mockup_ready notification to SessionDO for FID ${userFid}, Design ${designId}`);
                    }
                } else {
                    console.warn(`[Webhook Printful] Could not find FID for design ${designId} to send notification.`);
                }
            } catch (notifyError) {
                console.error(`[Webhook Printful] Error sending notification for design ${designId}:`, notifyError);
            }

            return c.json({ success: true }); // Acknowledge receipt
        } catch (e) {
            console.error(`[Webhook Printful] Failed to update database for design ${designId}:`, e);
            return c.json({ error: 'Database update failed' }, 500);
        }

    } else if (eventType === 'mockup_task_failed' && task) {
        const externalId = task.external_id;
        const reason = task.reason || 'Unknown error';
        
        if (!externalId) {
             console.error('[Webhook Printful] Missing external_id in failed event', payload);
             return c.json({ error: 'Missing external_id in failure payload' }, 400);
        }
        
        const designId = parseInt(externalId, 10);
        if (isNaN(designId)) {
            console.error('[Webhook Printful] Invalid external_id (designId) in failed event:', externalId);
            return c.json({ error: 'Invalid external_id' }, 400);
        }
        
        console.warn(`[Webhook Printful] Mockup task failed for design ${designId}. Reason: ${reason}`);
        
         try {
            await db.prepare(
                `UPDATE designs SET status = 'mockup_error', updated_at = datetime('now')
                 WHERE id = ? AND status = 'mockup_pending'`
            ).bind(designId).run();
            console.log(`[Webhook Printful] Updated status to mockup_error for design ${designId}.`);
            // TODO: Notify Session Durable Object about failure?
            try {
                 // Get the FID associated with this design
                const designInfo = await db.prepare(
                    `SELECT fid FROM designs WHERE id = ?`
                ).bind(designId).first();
                
                if (designInfo && designInfo.fid) {
                    const userFid = designInfo.fid;
                    const sessionDoBinding = c.env.SESSION_DO;
                    if (sessionDoBinding) {
                        const doId = sessionDoBinding.idFromName(userFid.toString());
                        const stub = sessionDoBinding.get(doId);
                        stub.fetch('http://do-session/notify', { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ type: 'mockup_error', designId, reason })
                        }); 
                         console.log(`[Webhook Printful] Sent mockup_error notification to SessionDO for FID ${userFid}, Design ${designId}`);
                    }
                } 
            } catch (notifyError) {
                 console.error(`[Webhook Printful] Error sending failure notification for design ${designId}:`, notifyError);
            }
        } catch (e) {
            console.error(`[Webhook Printful] Failed to update database status to error for design ${designId}:`, e);
            // Don't return 500, Printful might retry. Log error and return success.
        }
        
        return c.json({ success: true }); // Acknowledge receipt even on failure update

    } else {
        console.log(`[Webhook Printful] Received unhandled event type: ${eventType}`);
        return c.json({ message: 'Webhook received, event type not processed' });
    }
});

export default webhookRoutes;
</file>

<file path="src/routes/websockets.js">
import { Hono } from 'hono';
import { authMiddleware } from '../auth'; // Import auth middleware

const websocketRoutes = new Hono();

// Apply auth middleware - WebSocket connections should be authenticated
websocketRoutes.use('*', authMiddleware);

// GET /api/ws - Handles WebSocket upgrade requests
websocketRoutes.get('/', (c) => {
    const userFid = c.get('userFid');
    if (!userFid) {
        // Should be caught by middleware, but double-check
        return c.json({ error: 'Unauthorized: Missing user FID in context' }, 401);
    }

    // Check for the Upgrade header
    const upgradeHeader = c.req.header('Upgrade');
    if (!upgradeHeader || upgradeHeader.toLowerCase() !== 'websocket') {
        return new Response('Expected Upgrade: websocket', { status: 426 }); // 426 Upgrade Required
    }

    // Get the Durable Object binding
    const sessionDoBinding = c.env.SESSION_DO;
    if (!sessionDoBinding) {
        console.error('SESSION_DO binding missing in environment.');
        return new Response('Internal Server Error: WebSocket service not configured.', { status: 500 });
    }

    try {
        // Get the specific DO instance for this user FID
        const doId = sessionDoBinding.idFromName(userFid.toString());
        const stub = sessionDoBinding.get(doId);

        // Forward the request (including headers) to the Durable Object
        // The DO's fetch handler will perform the WebSocket handshake
        console.log(`Forwarding WebSocket request for FID ${userFid} to SessionDO ${doId.toString()}`);
        return stub.fetch(c.req.raw); 
    } catch (e) {
        console.error(`Error getting/fetching SessionDO for FID ${userFid}:`, e);
        return new Response('Internal Server Error: Could not establish WebSocket connection.', { status: 500 });
    }
});

export default websocketRoutes;
</file>

<file path="src/auth.js">
import { createAppClient, viemConnector } from '@farcaster/auth-client';
import { sign, verify } from '@tsndr/cloudflare-worker-jwt';

/**
 * Handles the Sign-In With Farcaster verification and JWT issuance.
 * @param {Request} request - The incoming request object.
 * @param {object} env - The worker environment object (must contain AUTH_SECRET).
 * @returns {Promise<Response>} - A Response object with the JWT or an error.
 */
export async function handleSignIn(request, env) {
    // --- Dynamically derive APP_DOMAIN from request URL ---
    let appDomain;
    try {
        const url = new URL(request.url);
        appDomain = url.port ? `${url.hostname}:${url.port}` : url.hostname;
        console.log(`handleSignIn: Derived APP_DOMAIN: ${appDomain} from request URL: ${request.url}`);
    } catch (e) {
        console.error("handleSignIn: Failed to parse request URL to derive APP_DOMAIN:", e);
        return Response.json({ success: false, message: 'Server configuration error (domain parsing).' }, { status: 500 });
    }
    // ---

    const { message, signature, nonce } = await request.json();

    if (!message || !signature || !nonce) {
        return Response.json({ success: false, message: 'Missing message, signature, or nonce.' }, { status: 400 });
    }

    if (!env.AUTH_SECRET) {
        console.error("handleSignIn: AUTH_SECRET environment variable not set!");
        return Response.json({ success: false, message: 'Authentication system configuration error.' }, { status: 500 });
    }

    try {
        // TODO: Consider adding nonce validation
        console.log(`handleSignIn: Verifying SIWF message for domain: ${appDomain}...`);

        const appClient = createAppClient({
            ethereum: viemConnector() // Assumes viem is available
        });

        const verifyResponse = await appClient.verifySignInMessage({
            message,
            signature,
            domain: appDomain,
            nonce,
        });

        // Use `.success` based on user's update
        if (!verifyResponse.success) { 
            console.error('handleSignIn: SIWF verification failed:', verifyResponse.error);
            const errorDetail = verifyResponse.error?.message || 'Unknown verification error';
            return Response.json({ success: false, message: `Signature verification failed: ${errorDetail}` }, { status: 401 });
        }

        const fid = verifyResponse.fid;
        console.log(`handleSignIn: Verification successful for FID: ${fid} (verified against domain: ${verifyResponse.domain})`);

        // --- Issue JWT ---
        const payload = {
            sub: fid.toString(),
            fid: fid, // Include fid directly as per user's update
            iss: appDomain,
            iat: Math.floor(Date.now() / 1000),
            exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 7) // 7 days expiry
        };

        const token = await sign(payload, env.AUTH_SECRET);
        console.log(`handleSignIn: JWT issued for FID: ${fid}`);
        // ---

        return Response.json({ success: true, token: token, fid: fid });

    } catch (error) {
        console.error('handleSignIn: Error during SIWF verification or JWT signing:', error);
        let errorMessage = 'An unexpected error occurred during sign-in.';
        if (error instanceof Error) {
            errorMessage = error.message;
        }
        return Response.json({ success: false, message: errorMessage }, { status: 500 });
    }
}

/**
 * Verifies a JWT token.
 * @param {string} token - The JWT string.
 * @param {string} secret - The secret key used for signing.
 * @returns {Promise<{isValid: boolean, payload?: object, error?: string}>} - Verification result.
 */
export async function verifyToken(token, secret) {
    try {
        const isValid = await verify(token, secret);
        if (!isValid) {
             return { isValid: false, error: 'Invalid token signature.' };
        }
        // Decode payload without verification (since we already verified signature)
        // Note: @tsndr/cloudflare-worker-jwt verify() only checks signature & expiry
        // For full claim validation (iss, aud, etc.), you might need another library or manual checks
        const { payload } = decode(token);
        // Optional: Check expiry again just to be sure (verify should handle it though)
        if (payload.exp && payload.exp * 1000 < Date.now()) {
            return { isValid: false, error: 'Token expired.' };
        }
        return { isValid: true, payload: payload };
    } catch (err) {
        console.error("Token verification error:", err);
         if (err.message === 'Expired JWT') {
             return { isValid: false, error: 'Token expired.' };
         }
        return { isValid: false, error: 'Invalid token format or verification failed.' };
    }
}

// Helper function to decode JWT payload (needed because verify only returns boolean)
function decode(token) {
    const parts = token.split('.');
    if (parts.length !== 3) {
        throw new Error('Invalid token format');
    }
    const [header, payload, signature] = parts;
    const decodedPayload = JSON.parse(atob(payload.replace(/-/g, '+').replace(/_/g, '/')));
    const decodedHeader = JSON.parse(atob(header.replace(/-/g, '+').replace(/_/g, '/')));
    return { header: decodedHeader, payload: decodedPayload, signature };
}

/**
 * Middleware to verify JWT token from Authorization header.
 * Sets c.userFid if valid.
 */
export const authMiddleware = async (c, next) => {
	// console.log("Auth Middleware triggered"); // Removed
	const authHeader = c.req.headers.get('Authorization');
	if (!authHeader || !authHeader.startsWith('Bearer ')) {
		// console.log("Auth Middleware: Missing/invalid header"); // Removed
		return c.json({ error: 'Unauthorized: Missing or invalid Authorization header.' }, 401);
	}
	const token = authHeader.substring(7); // Remove "Bearer "
	const secret = c.env.AUTH_SECRET;
	
	if (!secret) {
		console.error("Auth Middleware: AUTH_SECRET missing in environment!");
		return c.json({ error: 'Server configuration error.' }, 500);
	}

	// console.log(`Auth Middleware: Verifying token (first 10 chars): ${token.substring(0, 10)}...`); // Removed
	// console.log(`Auth Middleware: Using secret (type: ${typeof secret}, length: ${secret?.length})`); // Removed

	try {
		// console.log("Auth Middleware: Attempting jwt.verify..."); // Removed
		const isValid = await verify(token, secret, { algorithm: 'HS256' }); 
		// console.log(`Auth Middleware: jwt.verify result: ${isValid}`); // Removed
		
		if (!isValid) {
			// console.error("Auth Middleware: Token failed jwt.verify (isValid=false)"); // Removed
			throw new Error('Invalid token (verify step)');
		}

		// console.log("Auth Middleware: Attempting jwt.decode..."); // Removed
		const { payload } = decode(token);
		// console.log("Auth Middleware: Decoded payload:", payload); // Removed

		if (!payload || !payload.fid) {
			// console.error("Auth Middleware: Token payload invalid or missing fid"); // Removed
			throw new Error('Invalid token payload');
		}

		c.set('userFid', payload.fid);
		// console.log(`Auth Middleware: FID ${payload.fid} authorized and set in context.`); // Removed

	} catch (err) {
		console.error("Auth Middleware: Verification/Decode Error:", err.message); // Keep this error log
		return c.json({ error: 'Unauthorized: Invalid token.' }, 401);
	}

	// console.log("Auth Middleware: Proceeding to next handler..."); // Removed
	await next();
};
</file>

<file path="src/index.js">
import { Hono } from 'hono';
import { cors } from 'hono/cors';

// Import Routers
import publicRoutes from './routes/public';
import protectedRoutes from './routes/protected';
import adminRoutes from './routes/admin';
import webhookRoutes from './routes/webhooks';
import websocketRoutes from './routes/websockets';
import imageUtils from './routes/imageUtils';

// Import Scheduled Handler and DO Exports
import { handleScheduled } from './scheduled'; 
import { SessionDurableObject } from './do/session'; 
import { MockupQueueDurableObject } from './do/mockup_queue'; 

const app = new Hono();

// --- Global Middleware ---
app.use('/api/*', cors({
	origin: (origin) => {
		// Allow requests from localhost:3000 during development
		// TODO: Add production frontend URL(s) here
		const allowedOrigins = [
			'http://localhost:3000',
			'https://swag.kasra.codes' // Example production URL
		];
		if (allowedOrigins.includes(origin)) {
			return origin; 
		}
		// Allow other types of requests (e.g. mobile apps, curl)
		// Or handle them more strictly based on requirements
		return origin; // Allow any origin for now, refine later if needed
	},
	allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'], // MUST include OPTIONS
	allowHeaders: ['Content-Type', 'Authorization'], // MUST include Authorization and Content-Type
	maxAge: 600, // Cache preflight response for 10 minutes
	credentials: true, // Allow cookies if needed later (doesn't hurt now)
}));

// --- Register Routes (Revised Order) ---
// Register more specific routes first
app.route('/api/admin', adminRoutes);      // Handles /api/admin/*
app.route('/api/webhooks', webhookRoutes); // Handles /api/webhooks/*
app.route('/api/ws', websocketRoutes);     // Handles /api/ws/*

// Register broader /api routes
app.route('/api/image', imageUtils);      // <-- Register public image utils
app.route('/api', publicRoutes);         // Handles public /api/auth/signin, /api/products, /api/feed
app.route('/api', protectedRoutes);      // Handles protected /api/designs, /api/orders

// --- Root and Error Handling ---
app.get('/', (c) => c.text('FC Swag API - Root'));

app.notFound((c) => {
	return c.json({ error: 'Not Found', message: `The requested path ${c.req.url} was not found on this server.` }, 404);
})

app.onError((err, c) => {
	console.error(`[onError] ${c.req.url}: ${err}`, err.stack);
	return c.json({ error: 'Internal Server Error', message: err.message }, 500);
});

// --- Exports ---
export default {
	fetch: app.fetch,
	scheduled: handleScheduled,
};

// Export Durable Objects
export { SessionDurableObject }; 
export { MockupQueueDurableObject };
</file>

<file path="src/printful.js">
const BASE_URL = 'https://api.printful.com/v2';

/**
 * Helper function to make authenticated requests to the Printful API.
 * @param {string} endpoint - The API endpoint path (e.g., '/catalog-products/586')
 * @param {string} apiKey - The Printful API key.
 * @param {object} options - Fetch options (method, headers, body, etc.).
 * @returns {Promise<object>} - The JSON response from the API.
 * @throws {Error} - Throws an error if the request fails.
 */
async function fetchPrintfulAPI(endpoint, apiKey, options = {}) {
    const url = `${BASE_URL}${endpoint}`;
    const headers = {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
        ...options.headers,
    };

    const response = await fetch(url, { ...options, headers });

    if (!response.ok) {
        let errorBody = 'Could not read error body';
        try {
            errorBody = await response.json(); // Printful V2 uses application/problem+json
        } catch (e) { /* ignore */ }

        console.error(`Printful API Error (${response.status}): ${response.statusText} for ${url}`);
        console.error('Response Body:', JSON.stringify(errorBody));
        throw new Error(`Printful API request failed with status ${response.status}`);
    }

    return response.json();
}

/**
 * Fetches details for a specific catalog product.
 * @param {string|number} productId - The Printful Product ID.
 * @param {string} apiKey - The Printful API key.
 * @returns {Promise<object>} - The product data.
 */
export async function getPrintfulProduct(productId, apiKey) {
    console.log(`Fetching Printful product ${productId}...`);
    return fetchPrintfulAPI(`/catalog-products/${productId}`, apiKey);
}

/**
 * Fetches all variants for a specific catalog product.
 * Note: This currently fetches *all* variants. Printful API v2 doesn't seem to support filtering variants by color/size in this specific call.
 * We will filter them after fetching.
 * @param {string|number} productId - The Printful Product ID.
 * @param {string} apiKey - The Printful API key.
 * @returns {Promise<Array<object>>} - An array of variant data objects.
 */
export async function getPrintfulProductVariants(productId, apiKey) {
    console.log(`Fetching Printful variants for product ${productId}...`);
    // Need to handle potential pagination if a product has >100 variants, but 586 has 315. Default limit seems to be 20?
    // Let's fetch a larger limit for now. For robust solution, would need pagination loop.
    const result = await fetchPrintfulAPI(`/catalog-products/${productId}/catalog-variants?limit=100`, apiKey); // Fetch first 100
    let allVariants = result.data;

    // Basic pagination check (assuming 'next' link exists if more pages)
    let nextUrl = result._links?.next?.href;
    let safetyCounter = 0; // Prevent infinite loops
    const MAX_PAGES = 10;

    while (nextUrl && safetyCounter < MAX_PAGES) {
        console.log(`Fetching next page of variants: ${nextUrl}...`);
        // Need to strip the base URL from the next link provided by Printful
        const endpoint = nextUrl.replace(BASE_URL, '');
        const nextPageResult = await fetchPrintfulAPI(endpoint, apiKey);
        if (nextPageResult.data?.length > 0) {
            allVariants = allVariants.concat(nextPageResult.data);
        }
        nextUrl = nextPageResult._links?.next?.href;
        safetyCounter++;
    }
    if (safetyCounter === MAX_PAGES) {
        console.warn(`Reached max pagination limit (${MAX_PAGES}) for variants on product ${productId}. May be incomplete.`);
    }

    console.log(`Fetched total ${allVariants.length} variants for product ${productId}.`);
    return allVariants; 
}

/**
 * Fetches stock availability for a specific catalog product.
 * @param {string|number} productId - The Printful Product ID.
 * @param {string} apiKey - The Printful API key.
 * @returns {Promise<Array<object>>} - Availability data per variant/technique/region.
 */
export async function getPrintfulProductAvailability(productId, apiKey) {
    console.log(`Fetching Printful availability for product ${productId}...`);
    // Again, potentially need pagination for products with many variants
    const result = await fetchPrintfulAPI(`/catalog-products/${productId}/availability?limit=100`, apiKey);
    let allAvailability = result.data;

    let nextUrl = result._links?.next?.href;
    let safetyCounter = 0;
    const MAX_PAGES = 10;

    while (nextUrl && safetyCounter < MAX_PAGES) {
        console.log(`Fetching next page of availability: ${nextUrl}...`);
        const endpoint = nextUrl.replace(BASE_URL, '');
        const nextPageResult = await fetchPrintfulAPI(endpoint, apiKey);
        if (nextPageResult.data?.length > 0) {
            allAvailability = allAvailability.concat(nextPageResult.data);
        }
        nextUrl = nextPageResult._links?.next?.href;
        safetyCounter++;
    }
     if (safetyCounter === MAX_PAGES) {
        console.warn(`Reached max pagination limit (${MAX_PAGES}) for availability on product ${productId}. May be incomplete.`);
    }

    console.log(`Fetched availability for ${allAvailability.length} variant entries for product ${productId}.`);
    return allAvailability;
}

/**
 * Fetches product pricing information from Printful API v2.
 * @param {string|number} productId - The Printful Product ID.
 * @param {string} apiKey - The Printful API Key.
 * @param {string} currency - Optional currency code (e.g., 'USD'). Uses store default if omitted.
 * @returns {Promise<object>} - The pricing data object.
 */
export async function getPrintfulProductPrices(productId, apiKey, currency = 'USD') {
    const initialEndpoint = `/catalog-products/${productId}/prices?currency=${currency}&limit=100`;

    console.log(`Fetching initial page of Printful prices for product ${productId} in ${currency}...`);
    const initialResult = await fetchPrintfulAPI(initialEndpoint, apiKey);

    if (!initialResult || !initialResult.data || !initialResult.data.variants) {
        console.warn(`No pricing data or variants found in initial pricing response for product ${productId}`);
        return initialResult.data || {};
    }

    let allVariants = initialResult.data.variants;
    let nextUrl = initialResult._links?.next?.href;
    let safetyCounter = 0;
    const MAX_PAGES = 15;

    while (nextUrl && safetyCounter < MAX_PAGES) {
        console.log(`Fetching next page of prices: ${nextUrl}...`);
        const endpoint = nextUrl.replace(BASE_URL, '');
        try {
            const nextPageResult = await fetchPrintfulAPI(endpoint, apiKey);
            if (nextPageResult.data?.variants?.length > 0) {
                allVariants = allVariants.concat(nextPageResult.data.variants);
            }
            nextUrl = nextPageResult._links?.next?.href;
        } catch (error) {
            console.error(`Error fetching next page of prices (${nextUrl}):`, error);
            break;
        }
        safetyCounter++;
    }

    if (safetyCounter === MAX_PAGES) {
        console.warn(`Reached max pagination limit (${MAX_PAGES}) for prices on product ${productId}. May be incomplete.`);
    }

    console.log(`Fetched pricing for total ${allVariants.length} variants for product ${productId}.`);

    const finalData = initialResult.data;
    finalData.variants = allVariants;
    return finalData;
}

// New function to fetch mockup templates
export async function getPrintfulMockupTemplates(productId, apiKey, placement = null) {
    if (!apiKey) throw new Error('PRINTFUL_API_KEY is not set.');

    const url = new URL(`https://api.printful.com/v2/catalog-products/${productId}/mockup-templates`);
    if (placement) {
        url.searchParams.append('placements', placement);
    }
    // We might need pagination handling here if a product has many templates
    // For now, assume the first page is sufficient or Printful returns all for one placement.
    url.searchParams.append('limit', '100'); // Fetch up to 100 templates

    const headers = {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
    };

    try {
        const response = await fetch(url.toString(), { method: 'GET', headers });
        if (!response.ok) {
            let errorBody = 'Could not read error body';
            try {
                errorBody = await response.json();
            } catch (e) { /* ignore */ }
            console.error(`Printful API Error (${response.status}) for ${url.pathname}:`, errorBody);
            throw new Error(`Failed to fetch mockup templates: ${response.status} ${response.statusText}`);
        }
        const result = await response.json();
        return result.data || []; // Return the data array or empty if missing
    } catch (error) {
        console.error('Error fetching Printful mockup templates:', error);
        throw error;
    }
}

/**
 * Downloads an image from a URL.
 * @param {string} imageUrl The URL of the image to download.
 * @returns {Promise<{arrayBuffer: ArrayBuffer, contentType: string | null}>} The image data and content type.
 * @throws {Error} If the download fails or the response is not an image.
 */
export async function downloadImage(imageUrl) {
  try {
    console.log(`Downloading image: ${imageUrl}`);
    const response = await fetch(imageUrl);
    if (!response.ok) {
      throw new Error(`Failed to download image ${imageUrl}: ${response.status} ${response.statusText}`);
    }

    const contentType = response.headers.get('content-type');
    if (!contentType || !contentType.startsWith('image/')) {
        // Try to infer from URL extension if header is missing/wrong
        const extension = imageUrl.split('.').pop()?.toLowerCase();
        if (!['png', 'jpg', 'jpeg', 'gif', 'webp'].includes(extension)) {
             throw new Error(`Downloaded content from ${imageUrl} is not an image (Content-Type: ${contentType}, URL: ${imageUrl})`);
        }
         console.warn(`Missing or invalid image Content-Type (${contentType}) for ${imageUrl}. Proceeding based on extension.`);
    }

    const arrayBuffer = await response.arrayBuffer();
    console.log(`Downloaded ${imageUrl} (${(arrayBuffer.byteLength / 1024).toFixed(1)} KB)`);
    return { arrayBuffer, contentType };

  } catch (error) {
    console.error(`Error in downloadImage for ${imageUrl}:`, error);
    throw error; // Re-throw the error to be handled by the caller
  }
}
</file>

<file path="src/scheduled.js">
import {
    getPrintfulProductAvailability,
    getPrintfulProductPrices
} from './printful';

/**
 * Updates the inventory count and base price for variants of a given product.
 * @param {object} env - Worker environment object.
 * @param {number} dbProductId - The database ID of the product.
 * @param {string} printfulProductId - The Printful Product ID.
 */
async function updateProductVariants(env, dbProductId, printfulProductId) {
    console.log(`Updating variants for Product ID: ${dbProductId} (Printful ID: ${printfulProductId})`);
    const apiKey = env.PRINTFUL_API_KEY;
    if (!apiKey || !env.DB) {
        console.error(`Missing API Key or DB binding for product ${printfulProductId}`);
        return; // Skip this product if config is missing
    }

    const DEFAULT_INVENTORY = 100; // Match the seed script default
    const TARGET_TECHNIQUE = 'dtg';
    const TARGET_REGIONS = ['usa', 'europe']; // Match seed script

    try {
        // 1. Fetch latest data from Printful
        const [allAvailability, pricingData] = await Promise.all([
            getPrintfulProductAvailability(printfulProductId, apiKey),
            getPrintfulProductPrices(printfulProductId, apiKey, 'USD') // Fetch USD prices
        ]).catch(err => {
            console.error(`Failed to fetch Printful data for ${printfulProductId}:`, err);
            return [null, null]; // Allow function to continue to next product
        });

        if (!allAvailability || !pricingData) {
            console.log(`Skipping update for ${printfulProductId} due to fetch error.`);
            return;
        }

        // 2. Process Printful data into maps
        // Availability Map: variantId -> { isAvailable, isInStock }
        const availabilityMap = allAvailability.reduce((map, avail) => {
            const dtgTechniqueAvailability = avail.techniques?.find(t => t.technique === TARGET_TECHNIQUE);
            if (dtgTechniqueAvailability) {
                const isInStock = dtgTechniqueAvailability.selling_regions?.some(r => TARGET_REGIONS.includes(r.name) && r.availability === 'in stock');
                map[avail.catalog_variant_id] = {
                    isAvailable: true,
                    isInStock: isInStock
                };
            }
            return map;
        }, {});

        // Price Map: variantId -> price (float)
        const priceMap = {};
        if (pricingData && pricingData.variants) {
            pricingData.variants.forEach(variantPriceInfo => {
                const dtgTechnique = variantPriceInfo.techniques?.find(t => t.technique_key === TARGET_TECHNIQUE);
                if (dtgTechnique && dtgTechnique.price) {
                    priceMap[variantPriceInfo.id] = parseFloat(dtgTechnique.price);
                }
            });
        }

        // 3. Combine into update data: variant_sku -> { new_inventory, new_price }
        // We use variant_sku (Printful variant ID) as the key
        const updateDataMap = {};
        Object.keys(availabilityMap).forEach(variantIdStr => {
            const variantId = parseInt(variantIdStr, 10);
            const availability = availabilityMap[variantId];
            const price = priceMap[variantId]; // Already parsed to float or undefined

            if (availability) { // Only update variants we have availability info for
                updateDataMap[variantId] = {
                    new_inventory: availability.isInStock ? DEFAULT_INVENTORY : 0,
                    new_price: price !== undefined ? price : null // Store null if price wasn't found
                };
            }
        });

        if (Object.keys(updateDataMap).length === 0) {
             console.log(`No relevant variant data found from Printful for product ${printfulProductId}. Skipping D1 update.`);
             return;
        }

        // 4. Prepare D1 Update Statements
        const updateStmt = env.DB.prepare(
            `UPDATE product_variants
             SET inventory_count = ?, printful_price = ?, updated_at = CURRENT_TIMESTAMP
             WHERE product_id = ? AND variant_sku = ?`
        );

        const updateBindings = Object.entries(updateDataMap).map(([variantSku, data]) => {
            console.log(`  - Preparing update for SKU ${variantSku}: Inv=${data.new_inventory}, Price=${data.new_price}`);
            return updateStmt.bind(data.new_inventory, data.new_price, dbProductId, variantSku);
        });

        // 5. Batch Update D1
        console.log(`Batch updating ${updateBindings.length} variants in D1 for product ${dbProductId}...`);
        const batchResult = await env.DB.batch(updateBindings);
        console.log(`Batch update complete for product ${dbProductId}. Results:`, JSON.stringify(batchResult));

    } catch (error) {
        console.error(`Unhandled error updating product ${printfulProductId}:`, error);
        // Optionally, rethrow or handle differently
    }
}

/**
 * Scheduled event handler.
 */
export async function handleScheduled(event, env, ctx) {
    console.log(`Scheduled task started at: ${new Date(event.scheduledTime).toISOString()}`);

    try {
        // Get all products we manage
        const { results: productsToUpdate } = await env.DB.prepare(
            `SELECT id, printful_product_id FROM products WHERE status = 'active'`
        ).all();

        if (!productsToUpdate || productsToUpdate.length === 0) {
            console.log("No active products found to update.");
            return;
        }

        console.log(`Found ${productsToUpdate.length} active products to check for updates.`);

        // Update each product sequentially to avoid overwhelming Printful API/D1
        // For many products, consider a queue or staggering updates.
        for (const product of productsToUpdate) {
            // Use waitUntil to allow the function to finish while updates happen
            ctx.waitUntil(updateProductVariants(env, product.id, product.printful_product_id));
            // Optional: Add a small delay between products if rate limiting becomes an issue
            // await new Promise(resolve => setTimeout(resolve, 500)); 
        }

        console.log("Scheduled task finished initiating updates.");

    } catch (error) {
        console.error("Error during scheduled task:", error);
        // Consider reporting this error externally
    }
}
</file>

<file path="src/seed.js">
import {
    getPrintfulProduct,
    getPrintfulProductVariants,
    getPrintfulProductAvailability,
    getPrintfulProductPrices,
    getPrintfulMockupTemplates,
    downloadImage
} from './printful';

/**
 * Generates a URL-friendly slug from a string.
 * @param {string} text
 * @returns {string}
 */
function generateSlug(text) {
    return text
        .toString()
        .normalize('NFD') // split accented characters into their base characters and diacritical marks
        .replace(/[\u0300-\u036f]/g, '') // remove diacritical marks
        .toLowerCase()
        .trim()
        .replace(/\s+/g, '-') // replace spaces with -
        .replace(/[^\w-]+/g, '') // remove all non-word chars except -
        .replace(/--+/g, '-'); // replace multiple - with single -
}

/**
 * Fetches product data from Printful, filters it, and seeds the D1 database.
 * @param {object} env - The Worker environment (contains DB, PRINTFUL_API_KEY).
 * @param {string|number} productId - The Printful Product ID to seed.
 * @param {Array<string>} targetColors - List of color names to include.
 * @returns {Promise<object>} - A summary of the operation.
 */
export async function seedProductData(env, productId, targetColors) {
    const apiKey = env.PRINTFUL_API_KEY;
    const db = env.DB;
    if (!apiKey || !db || !env.R2_BUCKET || !env.R2_PUBLIC_URL) {
        console.error('Missing environment variables: PRINTFUL_API_KEY, DB binding, R2_BUCKET binding, or R2_PUBLIC_URL');
        return { success: false, message: 'Missing required environment configuration for seeding.' };
    }

    const targetColorsLower = targetColors ? targetColors.map(c => c.toLowerCase()) : []; // Ensure array even if null/undefined
    const DEFAULT_INVENTORY = 100; // Assign this if Printful says 'in stock'
    const TARGET_TECHNIQUE = 'dtg'; // This might need adjustment for non-DTG products like stickers (digital)
    const TARGET_REGIONS = ['usa', 'europe'];

    try {
        // 1. Fetch Product data first to determine type and placement
        console.log(`Fetching product data for Printful product ${productId}...`);
        const productData = await getPrintfulProduct(productId, apiKey);
        const productName = productData.data?.name;
        const productType = productData.data?.type; // e.g., 'T-SHIRT', 'STICKER'
        const productTechniqueKey = productData.data?.techniques?.find(t => t.is_default)?.key || 'digital'; // Use default or fallback
        
        if (!productName || !productType) {
            return { success: false, message: `Product ${productId} not found or critical data (name, type) is missing.` };
        }
        console.log(`Fetched product: ${productName} (Type: ${productType}, Default Technique: ${productTechniqueKey})`);

        // Determine the placement to fetch templates for
        const placementToFetch = productType === 'STICKER' ? 'default' : 'front';
        console.log(`Using placement '${placementToFetch}' for fetching templates based on product type.`);

        // Fetch remaining data
        console.log(`Fetching variants, availability, prices, and templates for Printful product ${productId}...`);
        const [allVariants, allAvailability, pricingData, mockupTemplates] = await Promise.all([
            getPrintfulProductVariants(productId, apiKey),
            getPrintfulProductAvailability(productId, apiKey),
            getPrintfulProductPrices(productId, apiKey, 'USD'),
            getPrintfulMockupTemplates(productId, apiKey, placementToFetch) // Use determined placement
        ]);
        console.log(`Fetched Printful data: ${allVariants.length} variants, ${mockupTemplates.length} templates for ${placementToFetch}.`);

        console.log(`Fetched ${allVariants.length} variants.`);
        console.log(`Fetched availability for ${allAvailability.length} entries.`);
        console.log(`Fetched pricing data.`);
        console.log(`Fetched ${mockupTemplates.length} mockup templates for '${placementToFetch}'.`);

        // --- Process Mockup Templates & Upload Images ---
        let commonTemplateData = null;
        const variantTextureR2UrlMap = {}; // { printful_variant_id: r2_texture_url }
        const uniqueImageUrlsToUpload = new Map(); // <printful_url, { hash, extension, r2_url }>

        if (mockupTemplates.length > 0) {
            const firstTemplate = mockupTemplates[0];

            // Process common overlay image URL
            if (firstTemplate.image_url) {
                if (!uniqueImageUrlsToUpload.has(firstTemplate.image_url)) {
                    const urlHash = await sha256(firstTemplate.image_url);
                    const extension = firstTemplate.image_url.split('.').pop()?.split('?')[0] || 'png'; // Basic extension guess
                    uniqueImageUrlsToUpload.set(firstTemplate.image_url, { hash: urlHash, extension, r2_url: null });
                }
            }

            // Process background/texture URLs
            for (const template of mockupTemplates) {
                if (template.background_url && !uniqueImageUrlsToUpload.has(template.background_url)) {
                    const urlHash = await sha256(template.background_url);
                    const extension = template.background_url.split('.').pop()?.split('?')[0] || 'jpg';
                    uniqueImageUrlsToUpload.set(template.background_url, { hash: urlHash, extension, r2_url: null });
                }
            }

            console.log(`Identified ${uniqueImageUrlsToUpload.size} unique template images to process.`);

            // Download and upload unique images in parallel
            const uploadPromises = [];
            for (const [printfulUrl, imageData] of uniqueImageUrlsToUpload.entries()) {
                uploadPromises.push(
                    (async () => {
                        try {
                            const { arrayBuffer, contentType } = await downloadImage(printfulUrl);
                            
                            // --- Generate readable filename from URL path ---
                            const urlPath = new URL(printfulUrl).pathname;
                            let filename = urlPath.substring(urlPath.lastIndexOf('/') + 1);
                            // Clean filename (remove query params just in case, though URL obj should handle it)
                            filename = filename.split('?')[0]; 
                            // Basic sanitization (replace potential problematic chars, though unlikely needed for Printful URLs)
                            filename = filename.replace(/[^a-zA-Z0-9_.-]/g, '_'); 
                            if (!filename) { // Fallback if extraction fails
                                filename = `template_${imageData.hash}.${imageData.extension}`;
                                console.warn(`Could not extract filename from ${printfulUrl}, using hash fallback: ${filename}`);
                            }
                            // --------------------------------------------------

                            // Pass productId to uploadToR2
                            imageData.r2_url = await uploadToR2(env, productId, filename, arrayBuffer, contentType); // Use new filename
                            uniqueImageUrlsToUpload.set(printfulUrl, imageData); // Update map with R2 URL
                        } catch (uploadError) {
                            console.error(`Failed to process image ${printfulUrl}: ${uploadError.message}`);
                            // Decide how to handle failures - skip this image? Fail the seed?
                            // For now, we log and continue, variants needing this image will have null URL.
                        }
                    })()
                );
            }
            await Promise.all(uploadPromises);
            console.log("Finished processing template image uploads.");

            // Now build the final data using the R2 URLs
            const commonOverlayR2Url = uniqueImageUrlsToUpload.get(firstTemplate.image_url)?.r2_url || null;
            commonTemplateData = {
                template_image_url: commonOverlayR2Url,
                template_width: firstTemplate.template_width,
                template_height: firstTemplate.template_height,
                print_area_width: firstTemplate.print_area_width,
                print_area_height: firstTemplate.print_area_height,
                print_area_top: firstTemplate.print_area_top,
                print_area_left: firstTemplate.print_area_left,
            };
            console.log("Common Template Data (using R2 URLs) extracted.");

            // Map texture R2 URLs to variants
            for (const template of mockupTemplates) {
                if (template.background_url) {
                    const textureR2Url = uniqueImageUrlsToUpload.get(template.background_url)?.r2_url || null;
                    if (textureR2Url) {
                        for (const variantId of template.catalog_variant_ids) {
                            variantTextureR2UrlMap[variantId] = textureR2Url;
                        }
                    }
                }
            }
            console.log(`Mapped ${Object.keys(variantTextureR2UrlMap).length} variants with R2 texture URLs.`);

        } else {
            console.warn(`No mockup templates found for product ${productId}, placement ${placementToFetch}. Template fields will be null.`);
        }
        // -------------------------------------------

        // Create availability map - adjust technique based on product?
        // Using productTechniqueKey fetched earlier instead of hardcoded TARGET_TECHNIQUE
        const availabilityMap = allAvailability.reduce((map, avail) => {
            const techniqueAvailability = avail.techniques?.find(t => t.technique === productTechniqueKey);
            if (techniqueAvailability) {
                const isInStock = techniqueAvailability.selling_regions?.some(r => TARGET_REGIONS.includes(r.name) && r.availability === 'in stock');
                map[avail.catalog_variant_id] = {
                    isAvailable: true,
                    isInStock: isInStock
                };
            }
            return map;
        }, {});

        // Create price map - adjust technique based on product?
        // Using productTechniqueKey instead of hardcoded TARGET_TECHNIQUE
        const priceMap = {};
        if (pricingData && pricingData.variants) {
            pricingData.variants.forEach(variantPriceInfo => {
                const techniquePrice = variantPriceInfo.techniques?.find(t => t.technique_key === productTechniqueKey);
                if (techniquePrice && techniquePrice.price) {
                    priceMap[variantPriceInfo.id] = techniquePrice.price;
                }
            });
            console.log(`Created price map for ${Object.keys(priceMap).length} variants using technique '${productTechniqueKey}'.`);
        } else {
            console.warn(`No pricing data or variants found in pricing response for product ${productId}`);
        }

        // ---> ADDED: Truncate Name at first '|'
        let processedProductName = productName;
        const pipeIndex = processedProductName.indexOf('|');
        if (pipeIndex !== -1) {
            processedProductName = processedProductName.substring(0, pipeIndex).trim();
        }
        // <---

        // 2. Process and Filter Variants
        const apparelSizes = ['S', 'M', 'L', 'XL']; // Sizes typically for apparel
        console.log(`Filtering variants. Target Colors: ${targetColorsLower.length > 0 ? targetColorsLower.join(', ') : '[All]'}. Applying size filter only for non-sticker types.`);
        
        const filteredVariants = allVariants.filter(variant => {
            // Availability Check (required for all)
            const isAvailable = availabilityMap[variant.id]?.isAvailable;
            if (!isAvailable) return false;

            // Color Filter (only if targetColors specified)
            if (targetColorsLower.length > 0) {
                const colorNameLower = variant.color?.toLowerCase();
                if (!colorNameLower || !targetColorsLower.includes(colorNameLower)) {
                    return false;
                }
            }

            // Size Filter (only for non-sticker types, using apparelSizes for now)
            if (productType !== 'STICKER') {
                 if (!variant.size || !apparelSizes.includes(variant.size)) {
                     return false;
                 }
            }
            // If we passed all applicable filters, include the variant
            return true;
        }).map(variant => ({
            printful_variant_id: variant.id,
            printful_product_id: variant.catalog_product_id,
            size: variant.size,
            color_name: variant.color,
            color_code: variant.color_code,
            printful_price: priceMap[variant.id] ? parseFloat(priceMap[variant.id]) : null,
            inventory_count: availabilityMap[variant.id]?.isInStock ? DEFAULT_INVENTORY : 0,
            template_image_url: commonTemplateData?.template_image_url || null,
            template_texture_url: variantTextureR2UrlMap[variant.id] || null,
            template_width: commonTemplateData?.template_width || null,
            template_height: commonTemplateData?.template_height || null,
            print_area_width: commonTemplateData?.print_area_width || null,
            print_area_height: commonTemplateData?.print_area_height || null,
            print_area_top: commonTemplateData?.print_area_top || null,
            print_area_left: commonTemplateData?.print_area_left || null,
            status: availabilityMap[variant.id]?.isInStock ? 'available' : 'out_of_stock'
        }));

        if (filteredVariants.length === 0) {
            // Add more context to the error message
            return { success: false, message: `No variants found matching criteria for product ${productId} (Type: ${productType}). Check availability, color filters (if used), and size filters (if applicable).` };
        }
        console.log(`Found ${filteredVariants.length} variants to seed after filtering.`);

        // 3. Prepare for D1
        // Slug generation - Make it more generic?
        // Let's use productId in slug for non-586 cases for now
        let productSlug;
        if (productId.toString() === '586') {
            productSlug = 'unisex-t-shirt';
            console.log(`Using hardcoded slug '${productSlug}' for Printful Product ID ${productId}`);
        } else {
            // Generic slug: type-id or name-id
            productSlug = generateSlug(`${productType}-${productId}`); // Use type and ID for uniqueness
            console.log(`Generated slug '${productSlug}' for Printful Product ID ${productId}`);
        }
        
        const productInsertStmt = db.prepare(
            'INSERT INTO products (name, slug, printful_product_id, status) VALUES (?, ?, ?, ?) ON CONFLICT(printful_product_id) DO UPDATE SET name=excluded.name, slug=excluded.slug, status=excluded.status, updated_at=CURRENT_TIMESTAMP RETURNING id'
        );

        // Corrected SQL Statement
        const variantUpsertStmt = db.prepare(`
            INSERT INTO product_variants (
                product_id, printful_variant_id, printful_product_id, color_name, color_code,
                size, printful_price, inventory_count, status,
                template_image_url, template_texture_url, template_width, template_height,
                print_area_width, print_area_height, print_area_top, print_area_left
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ON CONFLICT(printful_variant_id) DO UPDATE SET
                product_id = excluded.product_id,
                printful_product_id = excluded.printful_product_id,
                color_name = excluded.color_name,
                color_code = excluded.color_code,
                size = excluded.size,
                printful_price = excluded.printful_price,
                inventory_count = excluded.inventory_count,
                status = excluded.status,
                template_image_url = excluded.template_image_url,
                template_texture_url = excluded.template_texture_url,
                template_width = excluded.template_width,
                template_height = excluded.template_height,
                print_area_width = excluded.print_area_width,
                print_area_height = excluded.print_area_height,
                print_area_top = excluded.print_area_top,
                print_area_left = excluded.print_area_left,
                updated_at = CURRENT_TIMESTAMP
        `);

        // 4. Execute D1 Queries
        console.log(`Inserting/Updating product: ${processedProductName} (Slug: ${productSlug})`);
        const productResult = await productInsertStmt.bind(processedProductName, productSlug, productId, 'active').first();

        if (!productResult?.id) {
            throw new Error('Failed to insert or retrieve product ID from D1.');
        }
        const dbProductId = productResult.id;

        // Batch insert/update variants
        const variantBindings = filteredVariants.map(v =>
            variantUpsertStmt.bind(
                dbProductId, v.printful_variant_id, v.printful_product_id, v.color_name, v.color_code,
                v.size, v.printful_price, v.inventory_count, v.status,
                v.template_image_url, v.template_texture_url, v.template_width, v.template_height,
                v.print_area_width, v.print_area_height, v.print_area_top, v.print_area_left
            )
        );

        console.log(`Batch inserting/updating ${variantBindings.length} variants...`);
        const batchResult = await db.batch(variantBindings);

        console.log('D1 Batch Result Summary:', batchResult.map(r => ({ success: r.success, error: r.error })));
        const successCount = batchResult.filter(r => r.success).length;
        const failedCount = batchResult.length - successCount;

        if (failedCount > 0) {
            console.error(`Failed to insert/update ${failedCount} variants.`);
            // Optionally log more details about failures if needed
        }

        return {
            success: true, // Indicate overall process attempted
            message: `Seeded product ${productId} (${processedProductName}) with ID ${dbProductId}. Processed ${filteredVariants.length} variants (Succeeded: ${successCount}, Failed: ${failedCount}).`,
            productId: dbProductId,
            variantsProcessed: filteredVariants.length,
            variantsSucceeded: successCount
        };

    } catch (error) {
        console.error('Error during product seeding:', error);
        if (error.cause) {
            console.error('Caused by:', error.cause);
        }
        return { success: false, message: `Seeding failed: ${error.message}` };
    }
}

const TARGET_PRINTFUL_PRODUCT_ID = 586; // Comfort Colors 1717
const TARGET_COLORS = [ // From Frontend Day 1 Standup
  'Berry', 'Black', 'Blue Jean', 'Brick',
  'Grey', 'Moss', 'True Navy', 'White',
];
const TARGET_SIZES = ['S', 'M', 'L', 'XL']; // Defined in Backend Day 2 Standup
const TARGET_TECHNIQUE = 'dtg'; // Defined in Backend Day 1 Standup

async function seedDatabase(db, env) {
  console.log(`Starting seed process for Printful Product ID: ${TARGET_PRINTFUL_PRODUCT_ID}...`);

  try {
    // --- 1. Fetch Product Info ---
    // (Keep existing product fetching logic if necessary, or simplify if only one product is needed)
    // For MVP, we assume product 'Comfort Colors 1717' (ID 586) is already in DB or we create it here.
    // Ensure the base product exists
    const productName = "Unisex Garment-Dyed Heavyweight T-Shirt"; // Name for Comfort Colors 1717
    const productSlug = "comfort-colors-1717"; // Example slug
    let productResult = await db.prepare("SELECT id FROM products WHERE printful_product_id = ?")
                                 .bind(TARGET_PRINTFUL_PRODUCT_ID).first();

    let productId;
    if (!productResult) {
      console.log(`Product ${TARGET_PRINTFUL_PRODUCT_ID} not found, inserting...`);
      const insertResult = await db.prepare(
        "INSERT INTO products (printful_product_id, name, slug, status) VALUES (?, ?, ?, 'active') RETURNING id"
      ).bind(TARGET_PRINTFUL_PRODUCT_ID, productName, productSlug).first();
      productId = insertResult.id;
      console.log(`Inserted product with ID: ${productId}`);
    } else {
      productId = productResult.id;
      console.log(`Found existing product with ID: ${productId}`);
    }

    // --- 2. Fetch Variants & Prices ---
    console.log('Fetching variants from Printful...');
    const allVariants = await getPrintfulProductVariants(TARGET_PRINTFUL_PRODUCT_ID, env.PRINTFUL_API_KEY);
    console.log(`Fetched ${allVariants.length} total variants.`);

    console.log('Fetching prices from Printful...');
    const variantPrices = await getPrintfulProductPrices(TARGET_PRINTFUL_PRODUCT_ID, env.PRINTFUL_API_KEY); // Assuming this returns a map { printful_variant_id: price }
    console.log(`Fetched prices for ${Object.keys(variantPrices).length} variants.`);

    // --- 3. Fetch Mockup Template Data ---
    console.log('Fetching mockup template data (front placement) from Printful...');
    const mockupTemplates = await getPrintfulMockupTemplates(TARGET_PRINTFUL_PRODUCT_ID, env.PRINTFUL_API_KEY, 'front');
    console.log(`Fetched ${mockupTemplates.length} template definitions for 'front' placement.`);

    if (mockupTemplates.length === 0) {
      console.warn("Warning: No mockup template data found for 'front' placement. Cannot populate template/print area columns.");
      // Decide how to proceed: skip populating these fields or throw error? For now, skip.
    }

    // Process template data into a usable format
    // We need: common overlay image, boundaries, and variant-specific texture URLs
    let commonTemplateData = null;
    const variantTextureMap = {}; // { printful_variant_id: texture_url }

    if (mockupTemplates.length > 0) {
        // Assume the first template has the common data we need (boundaries, overlay image)
        const firstTemplate = mockupTemplates[0];
        commonTemplateData = {
            template_image_url: firstTemplate.image_url,
            template_width: firstTemplate.template_width,
            template_height: firstTemplate.template_height,
            print_area_width: firstTemplate.print_area_width,
            print_area_height: firstTemplate.print_area_height,
            print_area_top: firstTemplate.print_area_top,
            print_area_left: firstTemplate.print_area_left,
        };
        console.log("Common Template Data:", commonTemplateData);

        // Map texture URLs to variants that use them
        for (const template of mockupTemplates) {
            if (template.background_url) {
                for (const variantId of template.catalog_variant_ids) {
                    variantTextureMap[variantId] = template.background_url;
                }
            }
        }
        console.log(`Mapped ${Object.keys(variantTextureMap).length} variants with specific texture URLs.`);
    }


    // --- 4. Filter and Insert/Update Variants ---
    const variantsToSeed = allVariants.filter(variant =>
      TARGET_COLORS.includes(variant.color) &&
      TARGET_SIZES.includes(variant.size) &&
      variantPrices[variant.id] !== undefined // Ensure we have a price
      // Add technique filtering if available in variant data, otherwise assume DTG for this product
    );

    console.log(`Filtered down to ${variantsToSeed.length} variants matching target colors/sizes/price.`);

    if (variantsToSeed.length === 0) {
      console.warn('Warning: No variants matched the filtering criteria. Check TARGET_COLORS, TARGET_SIZES, and Printful data.');
      return { success: false, message: 'No matching variants found to seed.' };
    }

    // Prepare batch insert/update statement
    const stmt = db.prepare(`
      INSERT INTO product_variants (
        product_id, printful_variant_id, printful_product_id, color_name,
        color_code, size, printful_price, inventory_count, status,
        template_image_url, template_texture_url, template_width, template_height,
        print_area_width, print_area_height, print_area_top, print_area_left
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(printful_variant_id) DO UPDATE SET
        product_id = excluded.product_id,
        printful_product_id = excluded.printful_product_id,
        color_name = excluded.color_name,
        color_code = excluded.color_code,
        size = excluded.size,
        printful_price = excluded.printful_price,
        inventory_count = excluded.inventory_count, -- Or fetch live inventory here
        status = excluded.status,
        template_image_url = excluded.template_image_url,
        template_texture_url = excluded.template_texture_url,
        template_width = excluded.template_width,
        template_height = excluded.template_height,
        print_area_width = excluded.print_area_width,
        print_area_height = excluded.print_area_height,
        print_area_top = excluded.print_area_top,
        print_area_left = excluded.print_area_left,
        updated_at = CURRENT_TIMESTAMP
    `);

    const batchData = variantsToSeed.map(variant => {
        const price = variantPrices[variant.id];
        const templateData = commonTemplateData || {}; // Use empty object if no template data fetched
        const textureUrl = variantTextureMap[variant.id] || null;
        const inventoryCount = 100; // Placeholder inventory
        const status = 'available'; // Placeholder status

        return stmt.bind(
            productId,
            variant.id,
            TARGET_PRINTFUL_PRODUCT_ID, // Assuming variant.catalog_product_id exists, or use constant
            variant.color,
            variant.color_code || '#000000', // Default color code if missing
            variant.size,
            price,
            inventoryCount,
            status,
            templateData.template_image_url || null,
            textureUrl,
            templateData.template_width || null,
            templateData.template_height || null,
            templateData.print_area_width || null,
            templateData.print_area_height || null,
            templateData.print_area_top || null,
            templateData.print_area_left || null
        );
    });

    console.log(`Executing batch insert/update for ${batchData.length} variants...`);
    await db.batch(batchData);
    console.log('Batch insert/update complete.');

    console.log('Seed process finished successfully.');
    return { success: true, message: `Seeded/Updated ${batchData.length} variants for product ID ${productId}.` };

  } catch (error) {
    console.error('Error during seeding process:', error);
    if (error.cause) {
        console.error('Caused by:', error.cause);
    }
    // Attempt to log D1 specific errors if available
     if (error.message && error.message.includes('D1_ERROR')) {
       console.error('D1 Error details:', error);
     }
    return { success: false, message: `Seeding failed: ${error.message}` };
  }
}

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    if (request.method === 'POST' && url.pathname === '/api/admin/seed-product') {
        // Simple security check (replace with proper auth later)
        if (request.headers.get('X-Admin-Secret') !== env.ADMIN_AUTH_KEY) {
            return new Response('Unauthorized', { status: 401 });
        }

        try {
            const result = await seedProductData(env, TARGET_PRINTFUL_PRODUCT_ID, TARGET_COLORS);
            return new Response(JSON.stringify(result), {
                headers: { 'Content-Type': 'application/json' },
                status: result.success ? 200 : 500,
            });
        } catch (e) {
            console.error('Seeding endpoint error:', e);
            return new Response(JSON.stringify({ success: false, message: e.message }), { status: 500 });
        }
    }
    return new Response('Not Found', { status: 404 });
  },

  // Add scheduled handler if needed, e.g., for daily updates
   async scheduled(event, env, ctx) {
     // Implement daily price/inventory updates here if required
     console.log(`Scheduled task triggered: ${event.cron}`);
     // Example: await updateProductVariants(env.DB, env);
   }
};

// Helper to ensure updateProductVariants is defined if used in scheduled
async function updateProductVariants(db, env) {
    console.log("Running scheduled task to update product variants (price/inventory)...");
    // Add logic from BACKEND_DAY_2.md's scheduled.js here
    console.log("Scheduled task finished.");
}

// Helper function to generate SHA-256 hash (needed for filename generation)
// Uses the Web Crypto API available in Workers
async function sha256(message) {
    const msgUint8 = new TextEncoder().encode(message); // encode as (utf-8) Uint8Array
    const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8); // hash the message
    const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); // convert bytes to hex string
    return hashHex;
}

// Helper to upload to R2 and return public URL
async function uploadToR2(env, productId, filename, arrayBuffer, contentType) {
    if (!env.R2_BUCKET) {
        throw new Error('R2_BUCKET environment binding is not configured.');
    }
    if (!env.R2_PUBLIC_URL) {
        throw new Error('R2_PUBLIC_URL environment variable is not set.');
    }

    const r2Key = `product-templates/${productId}/${filename}`; // Create folder structure

    try {
        console.log(`Uploading ${r2Key} to R2...`); // Log the full key
        const options = { httpMetadata: { contentType } };
        await env.R2_BUCKET.put(r2Key, arrayBuffer, options); // Use r2Key
        const publicUrl = `${env.R2_PUBLIC_URL.replace(/\/$/, '')}/${r2Key}`; // Use r2Key in public URL
        console.log(`Uploaded to R2: ${publicUrl}`);
        return publicUrl;
    } catch (error) {
        console.error(`Failed to upload ${r2Key} to R2:`, error);
        throw new Error(`R2 upload failed for ${r2Key}: ${error.message}`);
    }
}
</file>

<file path="tests/designs.test.js">
import { describe, expect, it, beforeAll } from 'bun:test';
import jwt from '@tsndr/cloudflare-worker-jwt'; // For generating test JWT
import dotenv from 'dotenv';
import path from 'path';

// Load environment variables from .dev.vars
dotenv.config({ path: path.resolve(__dirname, '../.dev.vars') });

// Helper function to create a dummy image file Blob for testing
function createDummyImageFile(filename = 'test.png', type = 'image/png', size = 1024) {
    const buffer = new ArrayBuffer(size);
    return new File([buffer], filename, { type });
}

describe('Designs API Endpoint (Live Dev Server)', () => {
    let testToken; // JWT for authenticated requests
    const TEST_FID = 12345; // Example Farcaster ID for testing
    // Get AUTH_SECRET from environment (loaded from .dev.vars)
    const AUTH_SECRET = process.env.AUTH_SECRET;
    let testProductId = 1; // From previous DB query
    let testVariantId = 1; // From previous DB query
    const BASE_URL = 'http://localhost:8787'; // Target the running dev server
    let createdDesignId = null; // Store ID for potential cleanup or further tests

    beforeAll(async () => {
        if (!AUTH_SECRET) {
            throw new Error('AUTH_SECRET not found in environment. Make sure it is set in api/.dev.vars');
        }
        // Generate a test JWT token, explicitly setting HS256
        testToken = await jwt.sign({ fid: TEST_FID }, AUTH_SECRET, { algorithm: 'HS256' });
        console.log(`Using testToken: ${testToken.substring(0, 10)}...`);
        console.log(`Using test FID: ${TEST_FID}`);
        console.log(`Using test Product ID: ${testProductId}, Variant ID: ${testVariantId}`);
    });

    // No worker setup/teardown needed
    // TODO: Add afterAll to clean up created design?

    it('POST /api/designs should create a design and enqueue mockup task', async () => {
        const formData = new FormData();
        formData.append('product_id', testProductId.toString());
        formData.append('variant_id', testVariantId.toString());
        formData.append('image', createDummyImageFile('actual_test.png')); // Give a unique name

        const resp = await fetch(`${BASE_URL}/api/designs`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${testToken}`
                // Content-Type is set automatically by FormData
            },
            body: formData,
        });

        expect(resp.status).toBe(201); // Check for Created status
        const json = await resp.json();
        expect(json.success).toBe(true);
        expect(json.designId).toBeDefined();
        expect(json.designId).toBeGreaterThan(0);
        expect(json.imageUrl).toBeDefined();
        // Check against R2_PUBLIC_URL from env
        const expectedUrlPrefix = `${process.env.R2_PUBLIC_URL}/user-images/${TEST_FID}/${testProductId}/`;
        expect(json.imageUrl).toStartWith(expectedUrlPrefix);
        expect(json.imageUrl).toEndWith('.png');

        createdDesignId = json.designId; // Store for potential later use

        // TODO: Verify DB status - This is hard to do directly from bun:test against wrangler dev.
        // Option 1: Add a temporary debug endpoint GET /api/designs/:id/status (protected)
        // Option 2: Check wrangler dev logs for '[DO MockupQueue] Updated status for design X to mockup_pending'
        // For now, we rely on the 201 status and the DO logs.
        console.log(`Test check: Design ${createdDesignId} created. Verify 'mockup_pending' status manually via logs or DB query.`);
    });

    it('POST /api/designs should fail without authentication', async () => {
        const formData = new FormData();
        formData.append('product_id', testProductId.toString());
        formData.append('variant_id', testVariantId.toString());
        formData.append('image', createDummyImageFile());

        const resp = await fetch(`${BASE_URL}/api/designs`, {
            method: 'POST',
            body: formData,
        });
        expect(resp.status).toBe(401); // Unauthorized
        const json = await resp.json();
        expect(json.error).toContain('Unauthorized');
    });

    it('POST /api/designs should fail with missing required fields', async () => {
        const formData = new FormData();
        // Missing product_id and image
        formData.append('variant_id', testVariantId.toString());

        const resp = await fetch(`${BASE_URL}/api/designs`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${testToken}`
            },
            body: formData,
        });
        expect(resp.status).toBe(400); // Bad Request
        const json = await resp.json();
        expect(json.success).toBe(false);
        expect(json.message).toContain('Missing required fields');
    });

     it('POST /api/designs should fail with invalid variant_id (foreign key)', async () => {
        const formData = new FormData();
        formData.append('product_id', testProductId.toString());
        formData.append('variant_id', '999999'); // Non-existent variant ID
        formData.append('image', createDummyImageFile());

        const resp = await fetch(`${BASE_URL}/api/designs`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${testToken}`
            },
            body: formData,
        });
        expect(resp.status).toBe(400); // Bad Request due to FK constraint
        const json = await resp.json();
        expect(json.success).toBe(false);
        expect(json.message).toContain('Invalid product_id or variant_id');
    });

    // TODO: Add test for GET /api/designs (listing designs for the user)
});
</file>

<file path="tests/products.test.js">
import { describe, it, expect, beforeAll } from 'bun:test';

const API_URL = 'http://localhost:8787'; // Default wrangler dev port

describe('Product API Endpoints', () => {
    let testTargetDbProductId = null; // The database ID of the product we want to test variants for
    let fetchedProducts = [];

    // Fetch all products once and find the DB ID for our seeded Printful product
    beforeAll(async () => {
        try {
            const response = await fetch(`${API_URL}/api/products`);
            expect(response.status).toBe(200); // Expect success here
            const data = await response.json();
            fetchedProducts = data.products || [];

            const targetProduct = fetchedProducts.find(p => p.id === 1); // Hardcoding DB ID 1 based on manual check

            if (targetProduct) {
                testTargetDbProductId = targetProduct.id;
                console.log(`Found target product with DB ID: ${testTargetDbProductId} for testing variants.`);
            } else {
                // If we didn't find DB ID 1, log an error, tests might fail.
                console.error(`Error: Could not find the seeded product (expected DB ID 1) in the /api/products response.`);
                // Attempt to use the first product if available, but warn heavily
                if(fetchedProducts.length > 0) {
                    testTargetDbProductId = fetchedProducts[0].id;
                    console.warn(`Falling back to using the first available product DB ID: ${testTargetDbProductId}`);
                }
            }

        } catch (error) {
            console.error('Error during beforeAll product fetch/setup:', error);
            // Rethrow or handle so tests don't run with bad setup
            throw new Error(`Test setup failed: ${error.message}`);
        }
    });

    describe('GET /api/products', () => {
        it('should return a list of products with variants', async () => {
            // Response already fetched and basic structure checked in beforeAll
            expect(fetchedProducts).toBeInstanceOf(Array);

            // Check structure of the first product if available
            if (fetchedProducts.length > 0) {
                const product = fetchedProducts[0];
                expect(product).toHaveProperty('id');
                expect(product).toHaveProperty('name');
                expect(product).toHaveProperty('slug');
                expect(product).toHaveProperty('variants');
                expect(Array.isArray(product.variants)).toBe(true);

                // Check structure of the first variant if available
                if (product.variants.length > 0) {
                    const variant = product.variants[0];
                    expect(variant).toHaveProperty('id');
                    expect(variant).toHaveProperty('color_name');
                    expect(variant).toHaveProperty('size');
                    expect(variant).toHaveProperty('inventory_count');
                }
            }
        });
    });

    describe('GET /api/products/:product_id/variants', () => {
        it('should return 200 OK and variants for a valid product ID', async () => {
            if (!testTargetDbProductId) {
                throw new Error('Cannot run variant test: test setup did not find a target DB product ID.');
            }
            const response = await fetch(`${API_URL}/api/products/${testTargetDbProductId}/variants`);
            expect(response.status).toBe(200);

            const data = await response.json();
            expect(data).toHaveProperty('variants');
            expect(Array.isArray(data.variants)).toBe(true);

            // Check structure of the first variant if available
            if (data.variants.length > 0) {
                const variant = data.variants[0];
                 expect(variant).toHaveProperty('id');
                 expect(variant).toHaveProperty('color_name');
                 expect(variant).toHaveProperty('size');
                 expect(variant).toHaveProperty('inventory_count');
            }
        });

        it('should return 404 Not Found for a non-existent product ID', async () => {
            const nonExistentId = 'invalid-db-id-99999'; // Use an ID unlikely to exist in the DB
            const response = await fetch(`${API_URL}/api/products/${nonExistentId}/variants`);
            expect(response.status).toBe(404);
            const data = await response.json();
            expect(data).toHaveProperty('error');
            expect(data.error).toContain(`Product with ID ${nonExistentId} not found`);
        });

        // Hono usually handles routes without params as a 404 Not Found for the parent route
        // So a specific test for `/api/products//variants` isn't strictly necessary
        // unless you have specific middleware handling that case.
    });
});
</file>

<file path=".editorconfig">
# http://editorconfig.org
root = true

[*]
indent_style = tab
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.yml]
indent_style = space
</file>

<file path=".prettierrc">
{
	"printWidth": 140,
	"singleQuote": true,
	"semi": true,
	"useTabs": true
}
</file>

<file path="local_schema.sql">
 wrangler 4.14.1
-------------------

 Executing on local database fc_swag (42264697-0923-4fbc-8c55-bb904eee9ddf) from .wrangler/state/v3/d1:
 To execute on your remote database, add a --remote flag to your wrangler command.

[32mIf you think this is a bug then please create an issue at https://github.com/cloudflare/workers-sdk/issues/new/choose[0m
? Would you like to report this error to Cloudflare? Wrangler's output and the error details will be shared with the Wrangler team to help us diagnose and fix the issue.
 Using fallback value in non-interactive context: no
</file>

<file path="schema.sql">
-- Schema based on docs/INITIAL_DB_PLAN.md

-- 1. products Table: Stores each T-shirt style
CREATE TABLE IF NOT EXISTS products (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    printful_product_id INTEGER UNIQUE NOT NULL,  -- The ID from Printful API
    name TEXT NOT NULL,                           -- e.g., "Unisex Garment-Dyed Heavyweight T-Shirt"
    slug TEXT UNIQUE NOT NULL,                    -- URL-friendly identifier, e.g., "unisex-heavyweight-tee"
    status TEXT NOT NULL DEFAULT 'active' CHECK(status IN ('active', 'inactive', 'archived')),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for products table
CREATE INDEX IF NOT EXISTS idx_products_status ON products(status);
-- Note: UNIQUE constraint on slug implicitly creates an index

-- 2. product_variants Table: Tracks color variants and inventory
CREATE TABLE IF NOT EXISTS product_variants (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    product_id INTEGER NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    printful_variant_id INTEGER UNIQUE NOT NULL, -- The variant ID from Printful API
    printful_product_id INTEGER NOT NULL,        -- Denormalized for easier lookups if needed
    color_name TEXT NOT NULL,                    -- e.g., "Black", "Berry"
    color_code TEXT NOT NULL,                    -- e.g., "#000000", "#8e5a7b"
    size TEXT NOT NULL,                          -- e.g., "S", "M", "L", "XL"
    printful_price REAL NOT NULL,                -- Base price from Printful for this variant (USD)
    inventory_count INTEGER NOT NULL DEFAULT 0,  -- Current stock level
    status TEXT NOT NULL DEFAULT 'available' CHECK(status IN ('available', 'out_of_stock', 'discontinued')),
    -- New fields for canvas editor
    template_image_url TEXT,                     -- URL for the base t-shirt shape/overlay image
    template_texture_url TEXT,                   -- Optional texture URL for specific variants (like heather)
    template_width INTEGER,                      -- Width of the template canvas (pixels)
    template_height INTEGER,                     -- Height of the template canvas (pixels)
    print_area_width INTEGER,                    -- Width of the printable area (pixels)
    print_area_height INTEGER,                   -- Height of the printable area (pixels)
    print_area_top INTEGER,                      -- Top offset of the print area (pixels)
    print_area_left INTEGER,                     -- Left offset of the print area (pixels)
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for product_variants table
CREATE INDEX IF NOT EXISTS idx_variants_product ON product_variants(product_id);

-- Trigger to update 'updated_at' timestamp on products table changes
CREATE TRIGGER products_update_timestamp
AFTER UPDATE ON products
FOR EACH ROW
BEGIN
    UPDATE products SET updated_at = CURRENT_TIMESTAMP WHERE id = OLD.id;
END;

-- Trigger to update 'updated_at' timestamp on product_variants table changes
CREATE TRIGGER product_variants_update_timestamp
AFTER UPDATE ON product_variants
FOR EACH ROW
BEGIN
    UPDATE product_variants SET updated_at = CURRENT_TIMESTAMP WHERE id = OLD.id;
END;

-- Designs Table: Stores user-created designs.
CREATE TABLE designs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    fid INTEGER NOT NULL,                       -- Farcaster ID of the creator
    product_id INTEGER NOT NULL,                -- FK to products table
    variant_id INTEGER NOT NULL,                -- FK to product_variants table
    image_url TEXT NOT NULL,                    -- URL of the user-uploaded, transformed image stored in R2
    mockup_url TEXT,                            -- URL of the generated Printful mockup
    is_public BOOLEAN NOT NULL DEFAULT FALSE,   -- Whether the design is published and visible
    published_at DATETIME,                      -- Timestamp when the design was published
    royalty_percent INTEGER CHECK(royalty_percent >= 15 AND royalty_percent <= 30), -- Artist's royalty (15-30%)
    retail_price REAL,                          -- Calculated retail price at publish time
    artist_earn REAL,                           -- Calculated artist earnings per sale
    status TEXT NOT NULL DEFAULT 'draft' CHECK(status IN ('draft', 'mockup_generating', 'mockup_ready', 'published', 'error')),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (product_id) REFERENCES products (id),
    FOREIGN KEY (variant_id) REFERENCES product_variants (id)
);

-- Index for faster lookups by FID
CREATE INDEX idx_designs_fid ON designs (fid);
-- Index for public feed
CREATE INDEX idx_designs_public_published ON designs (is_public, published_at DESC) WHERE is_public = TRUE;

-- Trigger to update 'updated_at' timestamp on designs table changes
CREATE TRIGGER designs_update_timestamp
AFTER UPDATE ON designs
FOR EACH ROW
BEGIN
    UPDATE designs SET updated_at = CURRENT_TIMESTAMP WHERE id = OLD.id;
END;
</file>

<file path="wrangler.toml">
name = "fc-swag-api"
main = "src/index.js"
compatibility_date = "2025-05-02"

# Enable Node.js compatibility APIs
compatibility_flags = ["nodejs_compat"]

# Variables and Secrets
[vars]
# Define non-secret variables here
# EXAMPLE_VAR = "example_value"

# Secrets are managed via `wrangler secret put <name>`
# Required secrets: PRINTFUL_API_KEY, AUTH_SECRET

# D1 Database binding
[[d1_databases]]
binding = "DB"                 # i.e. env.DB
database_name = "fc_swag"
database_id = "42264697-0923-4fbc-8c55-bb904eee9ddf"

# R2 Bucket binding
[[r2_buckets]]
binding = "R2_BUCKET"
bucket_name = "swag-images"

# Durable Object bindings
[[migrations]]
tag = "v1" # Should be unique for each entry
new_classes = ["SessionDurableObject", "MockupQueueDurableObject"]

[durable_objects]
bindings = [
  { name = "SESSION_DO", class_name = "SessionDurableObject" },
  { name = "MOCKUP_QUEUE_DO", class_name = "MockupQueueDurableObject" }
]

# Environment-specific settings (optional)
# [env.production]
# name = "fc-swag-api-prod"

# Scheduled Task Configuration
[triggers]
# Cron format: <Minute> <Hour> <Day_of_Month> <Month> <Day_of_Week>
# Example: Run daily at midnight UTC
crons = ["0 0 * * *"]
</file>

<file path=".gitignore">
# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
\*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
\*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

\*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

\*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.cache
.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

.cache/

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp
.cache

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.\*

# wrangler project

.dev.vars
.wrangler/
</file>

<file path="package.json">
{
	"name": "fc-swag-api",
	"version": "0.0.0",
	"private": true,
	"scripts": {
		"deploy": "wrangler deploy",
		"dev": "wrangler dev",
		"start": "wrangler dev"
	},
	"dependencies": {
		"@farcaster/auth-client": "^0.3.0",
		"@tsndr/cloudflare-worker-jwt": "^3.1.4",
		"hono": "^3.0.0",
		"viem": "^2.28.3"
	},
	"devDependencies": {
		"wrangler": "^4.14.1"
	}
}
</file>

</files>
